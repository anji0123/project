Sql advanced with notes
Data warehouse concepts
Aure real time project videos
Azure classes playlist
Pyspark classes or course
Python basics(teams videos) 
Power bi classes ( teams videos) 
Big data 9hours video

Hands-on: Stream + Batch + Power BI dashboaüìÖ
 Phase 1 (Python + SQL) ‚Üí Aug 25 ‚Äì Oct 17


---

Week 1

Aug 25 (Mon)

Python: Variables & Data Types

Theory Q: What is the difference between mutable and immutable types in Python?

Code Q: Reverse a string without using slicing.


SQL: SELECT, WHERE

Theory Q: Difference between WHERE and HAVING clause?

Code Q: Query employees with salary > 50,000.



Aug 26 (Tue)

Python: Lists & Tuples

Theory Q: Why is a tuple faster than a list in Python?

Code Q: Find the 2nd largest number in a list.


SQL: ORDER BY, DISTINCT

Theory Q: What is the use of DISTINCT?

Code Q: Query top 3 highest salaries.



Aug 27 (Wed)

Python: Dictionaries & Sets

Theory Q: Why dictionary is faster than list for lookups?

Code Q: Count word frequency in a string.


SQL: Aggregate Functions

Theory Q: Difference between COUNT(*) and COUNT(column)?

Code Q: Find average salary per department.



Aug 28 (Thu)

Python: If-else, Loops

Theory Q: Difference between while and for loop?

Code Q: Check if a number is prime.


SQL: GROUP BY, HAVING

Theory Q: Why can‚Äôt we use WHERE with aggregate functions?

Code Q: Find departments with avg salary > 60k.



Aug 29 (Fri)

Python: Functions

Theory Q: What are default arguments in Python functions?

Code Q: Fibonacci series using recursion.


SQL: JOINS (INNER)

Theory Q: Difference between INNER JOIN and EQUIJOIN?

Code Q: Query employees with their department names.




---

Week 2

Sep 1 (Mon)

Python: Lambda, map, filter, reduce

Theory Q: When to use lambda vs def?

Code Q: Square all numbers in a list using map.


SQL: LEFT JOIN

Theory Q: Difference between LEFT JOIN and INNER JOIN?

Code Q: List all employees and their dept (even if dept missing).

                                                                    üêç Python: List Comprehension
                                                                    ‚úÖ Theory Q: What is the advantage of list comprehension?
                                                                    List comprehension is a concise way to create lists in Python. Instead of using loops, you write everything in a single line.
                                                                    
                                                                    üîπ Advantages:
                                                                    Cleaner syntax: Easier to read and write
                                                                    
                                                                    Faster execution: Optimized under the hood
                                                                    
                                                                    More Pythonic: Preferred in interviews and real codebases
                                                                    
                                                                    üí° Example comparison:
                                                                    
                                                                    python
                                                                    # Traditional loop
                                                                    evens = []
                                                                    for i in range(50):
                                                                        if i % 2 == 0:
                                                                            evens.append(i)
                                                                    
                                                                    # List comprehension
                                                                    evens = [i for i in range(50) if i % 2 == 0]
                                                                    üßÆ Code Q: Generate even numbers less than 50
                                                                    python
                                                                    even_numbers = [i for i in range(50) if i % 2 == 0]
                                                                    print(even_numbers)
                                                                    üîç Output: [0, 2, 4, 6, ..., 48]
                                                                    
                                                                    üóÉÔ∏è SQL: RIGHT JOIN
                                                                    ‚úÖ Theory Q: Difference between LEFT JOIN and RIGHT JOIN?
                                                                    Join Type	Description
                                                                    LEFT JOIN	Returns all rows from the left table, and matched rows from the right
                                                                    RIGHT JOIN	Returns all rows from the right table, and matched rows from the left
                                                                    üí° Think of it like this:
                                                                    
                                                                    LEFT JOIN = ‚ÄúGive me everything from Table A, even if Table B is missing‚Äù
                                                                    
                                                                    RIGHT JOIN = ‚ÄúGive me everything from Table B, even if Table A is missing‚Äù
                                                                    
                                                                    üßÆ Code Q: List all departments and employees (even if employee missing)
                                                                    Assume two tables:
                                                                    
                                                                    sql
                                                                    Departments
                                                                    -----------
                                                                    DeptID | DeptName
                                                                       1   | HR
                                                                       2   | IT
                                                                       3   | Finance
                                                                    
                                                                    Employees
                                                                    ----------
                                                                    EmpID | EmpName | DeptID
                                                                     101  | Alice   | 1
                                                                     102  | Bob     | 2
                                                                    üîπ SQL Query:
                                                                    sql
                                                                    SELECT d.DeptName, e.EmpName
                                                                    FROM Employees e
                                                                    RIGHT JOIN Departments d ON e.DeptID = d.DeptID;
                                                                    üîç Output:
                                                                    
                                                                    Code
                                                                    DeptName | EmpName
                                                                    HR       | Alice
                                                                    IT       | Bob
                                                                    Finance  | NULL   -- No employee in Finance
                                                                    üß† How to Use This in Interviews
                                                                    When asked:
                                                                    
                                                                    ‚ÄúWhat‚Äôs the difference between LEFT and RIGHT JOIN?‚Äù
                                                                    
                                                                    You say:
                                                                    
                                                                    ‚ÄúLEFT JOIN keeps all rows from the left table, RIGHT JOIN keeps all rows from the right. For example, if I want to list all departments even if no employee is assigned, I‚Äôd use RIGHT JOIN.‚Äù
                                                                    
                                                                    When asked:
                                                                    
                                                                    ‚ÄúHow do you generate even numbers in Python?‚Äù
                                                                    
                                                                    You say:
                                                                    
                                                                    ‚ÄúI‚Äôd use list comprehension for cleaner syntax: [i for i in range(50) if i % 2 == 0].‚Äù
                                                                    
                                                                    Sep 2 (Tue)
                                                                    
                                                                    Python: List comprehension
                                                                    
                                                                    Theory Q: Advantage of list comprehension?
                                                                    
                                                                    Code Q: Generate even numbers < 50.
                                                                    
                                                                    
                                                                    SQL: RIGHT JOIN
                                                                    
                                                                    Theory Q: Difference between LEFT and RIGHT join?
                                                                    
                                                                    Code Q: List all departments and employees (even if employee missing).



Sep 3 (Wed)

Python: Error handling (try, except)

Theory Q: Difference between Exception and Error in Python?

Code Q: Handle division by zero gracefully.

SQL: FULL OUTER JOIN
                                                                     
Theory Q: When to use FULL OUTER JOIN?
                                                                     
Code Q: List all employees and all departments.
                                                                     üêç PYTHON: Error Handling (try, except)
                                                                     üîπ What is Error Handling?
                                                                     Imagine you're driving a car and suddenly a pothole appears. Instead of crashing, you slow down and steer around it. That‚Äôs what error handling does in code‚Äîit prevents your program from crashing when something unexpected happens.
                                                                     
                                                                     ‚úÖ What‚Äôs the Difference Between Error and Exception?
                                                                     Term	Meaning	Can be handled?
                                                                     Error	Serious issues like syntax mistakes or memory overflow	‚ùå No
                                                                     Exception	Runtime problems like dividing by zero or missing files	‚úÖ Yes
                                                                     Examples:
                                                                     
                                                                     SyntaxError: You forgot a colon or bracket ‚Üí Error
                                                                     
                                                                     ZeroDivisionError: You tried dividing by 0 ‚Üí Exception
                                                                     
                                                                     üîπ Why Use try and except?
                                                                     To catch exceptions and respond gracefully.
                                                                     
                                                                     ‚úÖ Syntax:
                                                                     python
                                                                     try:
                                                                         # risky code
                                                                     except ExceptionType:
                                                                         # what to do if error happens
                                                                     üß™ Code Example: Division by Zero
                                                                     python
                                                                     try:
                                                                         a = int(input("Enter numerator: "))
                                                                         b = int(input("Enter denominator: "))
                                                                         result = a / b
                                                                         print("Result:", result)
                                                                     except ZeroDivisionError:
                                                                         print("Oops! You can't divide by zero.")
                                                                     except ValueError:
                                                                         print("Please enter valid numbers.")
                                                                     üîç Explanation:
                                                                     try: Runs the code that might fail
                                                                     
                                                                     except ZeroDivisionError: Catches division by zero
                                                                     
                                                                     except ValueError: Catches non-numeric input
                                                                     
                                                                     Program keeps running instead of crashing
                                                                     
                                                                     üß† Bonus: finally and else
                                                                     finally: Runs no matter what, even if there‚Äôs an error
                                                                     
                                                                     else: Runs only if no error occurs
                                                                     
                                                                     python
                                                                     try:
                                                                         print("Trying...")
                                                                         x = 1 / 1
                                                                     except:
                                                                         print("Error occurred")
                                                                     else:
                                                                         print("No error!")
                                                                     finally:
                                                                         print("Always runs")
                                                                     üõ¢Ô∏è SQL: FULL OUTER JOIN
                                                                     üîπ What is a JOIN?
                                                                     A JOIN connects two tables based on a common column‚Äîlike matching employee IDs with department IDs.
                                                                     
                                                                     ‚úÖ Types of JOINs
                                                                     JOIN Type	What It Shows
                                                                     INNER JOIN	Only matching rows from both tables
                                                                     LEFT JOIN	All rows from left + matched from right
                                                                     RIGHT JOIN	All rows from right + matched from left
                                                                     FULL OUTER JOIN	All rows from both tables, matched or not
                                                                     üîç FULL OUTER JOIN Explained
                                                                     Imagine two circles:
                                                                     
                                                                     One for employees
                                                                     
                                                                     One for departments
                                                                     
                                                                     A FULL OUTER JOIN gives you everything in both circles, even if there‚Äôs no match.
                                                                     
                                                                     üß™ Code Example: List All Employees and All Departments
                                                                     sql
                                                                     SELECT e.name, d.department_name
                                                                     FROM employees e
                                                                     FULL OUTER JOIN departments d
                                                                     ON e.department_id = d.id;
                                                                     ‚úÖ What This Does:
                                                                     Shows employees with departments
                                                                     
                                                                     Shows departments with no employees
                                                                     
                                                                     Shows employees without departments
                                                                     
                                                                     Fills missing values with NULL
                                                                     
                                                                     üß† Real-Life Analogy
                                                                     Think of a school:
                                                                     
                                                                     Some students are assigned to classes
                                                                     
                                                                     Some classes have no students
                                                                     
                                                                     Some students haven‚Äôt been assigned yet
                                                                     
                                                                     A FULL OUTER JOIN shows everyone and every class, even if they‚Äôre not connected.
                                                                     
                                                                     üéì Summary for Sep 3 (Wed)
                                                                     Topic	What You Learned
                                                                     Python Error Handling	Use try, except, finally, else to manage runtime issues
                                                                     Exception vs Error	Exceptions can be caught; errors usually crash
                                                                     Division by Zero	Catch with ZeroDivisionError
                                                                     SQL FULL OUTER JOIN	Combines all rows from both tables, even unmatched ones
                                                                     Use Case	Great for audits, completeness checks, and data reconciliation
                                                                     
                                                               
                                                                     
                                                                     

Sep 4 (Thu)

Python: File Handling

Theory Q: Modes of opening files in Python?

Code Q: Count number of lines in a file.

explain each and every term and all the stuff related to this concepts for thoery 
and practical wise even for a kid to understand 
and shoould also cover INterview point of view for a azure data engineer in 5/3 bank

SQL: UNION vs UNION ALL

Theory Q: Difference between UNION and UNION ALL?

Code Q: Combine employee names from two tables removing duplicates.



Sep 5 (Fri)

Python: OOP ‚Äì Classes & Objects

Theory Q: What is init in Python?

Code Q: Create a Student class with attributes and display details.


SQL: Subqueries

Theory Q: Difference between correlated and non-correlated subquery?

Code Q: Find employees whose salary > average salary.




---

Week 3

Sep 8 (Mon)

Python: OOP ‚Äì Inheritance

Theory Q: What is multiple inheritance? How does Python handle it?

Code Q: Demonstrate single & multiple inheritance with classes.


SQL: EXISTS & IN

Theory Q: Difference between IN and EXISTS?

Code Q: Find employees working in departments that exist in dept table.



Sep 9 (Tue)

Python: OOP ‚Äì Polymorphism

Theory Q: What is method overriding?

Code Q: Implement method overriding with Animal ‚Üí Dog class.


SQL: ANY & ALL

Theory Q: Difference between ANY and ALL operators?

Code Q: Find employees earning more than ALL employees in dept 10.



Sep 10 (Wed)

Python: OOP ‚Äì Encapsulation

Theory Q: What is the purpose of private variables in Python?

Code Q: Create a BankAccount class with deposit & withdraw methods.


SQL: CASE statement

Theory Q: When do we use CASE in SQL?

Code Q: Show employees with grade ‚ÄòHigh‚Äô if salary > 70k else ‚ÄòLow‚Äô.



Sep 11 (Thu)

Python: OOP ‚Äì Abstraction

Theory Q: What is an abstract class in Python?

Code Q: Create an abstract class Vehicle with method drive().


SQL: Stored Procedures (Intro)

Theory Q: Difference between procedure and function?

Code Q: Write a procedure to increase all salaries by 10%.



Sep 12 (Fri)

Python: Modules & Packages

Theory Q: Difference between module and package in Python?

Code Q: Create a package with math utilities and import it.


SQL: Functions in SQL

Theory Q: Difference between scalar and table-valued functions?

Code Q: Write a function to return total salary of a department.




---

Week 4

Sep 15 (Mon)

Python: Iterators & Generators

Theory Q: Difference between iterator and generator?

Code Q: Write a generator for Fibonacci numbers.


SQL: Indexing

Theory Q: Difference between clustered and non-clustered index?

Code Q: Create an index on salary column.



Sep 16 (Tue)

Python: Decorators

Theory Q: What are decorators in Python?

Code Q: Create a decorator to log function execution time.


SQL: Views

Theory Q: Advantages of using views?

Code Q: Create a view showing employee name and dept.



Sep 17 (Wed)

Python: Itertools

Theory Q: What is itertools used for?

Code Q: Use itertools to generate all permutations of a list.


SQL: CTEs

Theory Q: Difference between CTE and subquery?

Code Q: Use CTE to calculate running total of salaries.



Sep 18 (Thu)

Python: Collections Module

Theory Q: What is Counter in collections?

Code Q: Count character frequency in a string using Counter.


SQL: Window Functions (ROW_NUMBER)

Theory Q: Difference between RANK, DENSE_RANK, ROW_NUMBER?

Code Q: Assign row numbers to employees ordered by salary.



Sep 19 (Fri)

Python: Multithreading

Theory Q: Difference between multithreading and multiprocessing?

Code Q: Create two threads printing even & odd numbers separately.


SQL: Window Functions (RANK, DENSE_RANK)

Theory Q: Difference between RANK and DENSE_RANK?

Code Q: Find top 3 earners in each department.




---

Week 5

Sep 22 (Mon)

Python: Multiprocessing

Theory Q: When to use multiprocessing instead of multithreading?

Code Q: Use multiprocessing to calculate squares of a list.


SQL: PARTITION BY

Theory Q: Difference between GROUP BY and PARTITION BY?

Code Q: Find running total of salary partitioned by dept.



Sep 23 (Tue)

Python: Virtual Environments

Theory Q: Why do we use virtualenv in Python?

Code Q: Create a virtual environment and install pandas.


SQL: Common Aggregations with Window

Theory Q: Difference between SUM() OVER and SUM() with GROUP BY?

Code Q: Show cumulative salary by employee order.



Sep 24 (Wed)

Python: Pip & Package Management

Theory Q: Difference between pip and conda?

Code Q: Install numpy and check version in code.


SQL: Recursive CTE

Theory Q: What is a recursive CTE?

Code Q: Print hierarchy of employees under a manager.



Sep 25 (Thu)

Python: JSON Handling

Theory Q: Difference between json.load() and json.loads()?

Code Q: Parse a JSON file of employee records.


SQL: Transactions

Theory Q: ACID properties in SQL?

Code Q: Demonstrate BEGIN, COMMIT, ROLLBACK.



Sep 26 (Fri)

Python: Regex Basics

Theory Q: What are greedy vs non-greedy regex?

Code Q: Extract all emails from a text.


SQL: Triggers

Theory Q: What is a trigger in SQL?

Code Q: Create a trigger to log updates on salary.




---

Week 6

Sep 29 (Mon)

Python: Advanced Regex

Theory Q: What is the use of lookahead and lookbehind in regex?

Code Q: Extract all numbers from a string using regex.


SQL: Normalization (1NF‚Äì3NF)

Theory Q: What is difference between 2NF and 3NF?

Code Q: Normalize a sample employee table to 3NF.



Sep 30 (Tue)

Python: Date & Time

Theory Q: Difference between datetime.now() and utcnow()?

Code Q: Print current date in YYYY-MM-DD format.


SQL: Denormalization

Theory Q: When is denormalization used?

Code Q: Merge dept and employee table into a denormalized view.



Oct 1 (Wed)

Python: Logging

Theory Q: Why use logging instead of print()?

Code Q: Write logs to file with timestamp.


SQL: Stored Procedures Advanced

Theory Q: Can stored procedures return multiple result sets?

Code Q: Procedure to fetch top N salaries by dept.



Oct 2 (Thu)

Python: Unit Testing

Theory Q: What is unittest in Python?

Code Q: Write unittest for add(a, b).


SQL: Functions Advanced

Theory Q: Difference between deterministic and non-deterministic function?

Code Q: Write function to calculate factorial.



Oct 3 (Fri)

Python: Itertools Advanced

Theory Q: What is product() in itertools?

Code Q: Generate cartesian product of two lists.


SQL: Index Optimization

Theory Q: When does index slow down performance?

Code Q: Create composite index on (dept, salary).




---

Week 7

Oct 6 (Mon)

Python: CSV Handling

Theory Q: Difference between csv.reader and csv.DictReader?

Code Q: Read CSV and calculate column sum.


SQL: Temp Tables

Theory Q: Difference between temp table and table variable?

Code Q: Create a temp table for employees with salary > 70k.



Oct 7 (Tue)

Python: Pandas Intro

Theory Q: Difference between Series and DataFrame?

Code Q: Read CSV into DataFrame and show first 5 rows.


SQL: Optimization Basics

Theory Q: How to check execution plan in SQL?

Code Q: Compare query with and without index.



Oct 8 (Wed)

Python: Pandas Indexing

Theory Q: Difference between loc and iloc?

Code Q: Select all employees with salary > 50k using pandas.


SQL: Query Tuning

Theory Q: Difference between nested loop and hash join?

Code Q: Rewrite slow query using join optimization.



Oct 9 (Thu)

Python: Pandas GroupBy

Theory Q: Difference between groupby() and pivot_table()?

Code Q: Find average salary per dept in pandas.


SQL: Materialized Views

Theory Q: Difference between normal view and materialized view?

Code Q: Create materialized view of dept salaries.



Oct 10 (Fri)

Python: Pandas Merge & Join

Theory Q: Difference between merge and join in pandas?

Code Q: Merge employees with dept DataFrame.


SQL: Partition Tables

Theory Q: Why partition a table?

Code Q: Partition employees table by dept.




---

Week 8

Oct 13 (Mon)

Python: Numpy Basics

Theory Q: Difference between numpy array and Python list?

Code Q: Create numpy array and calculate mean.


SQL: OLAP vs OLTP

Theory Q: Difference between OLAP and OLTP?

Code Q: Show example schema for OLAP.



Oct 14 (Tue)

Python: Numpy Indexing & Slicing

Theory Q: Difference between shallow copy and deep copy in numpy?

Code Q: Slice numpy array into 2 halves.


SQL: Fact & Dimension Tables

Theory Q: Difference between fact and dimension tables?

Code Q: Design star schema with employee and dept.



Oct 15 (Wed)

Python: Numpy Operations

Theory Q: Difference between broadcasting and vectorization?

Code Q: Multiply two numpy arrays element-wise.


SQL: Slowly Changing Dimensions

Theory Q: Difference between SCD Type 1 and Type 2?

Code Q: Create SQL script for SCD Type 2 on employee table.



Oct 16 (Thu)

Python: Numpy Aggregations

Theory Q: What are axis parameters in numpy?

Code Q: Find sum across rows of 2D numpy array.


SQL: Data Warehousing Basics

Theory Q: Difference between star and snowflake schema?

Code Q: Write query for sales fact joining product dimension.



Oct 17 (Fri)

Python: Final Revision + Mini Mock

Theory Q: Explain Python memory management.

Code Q: Write function to check if string is palindrome.


SQL: Final Revision + Mini Mock

Theory Q: Difference between OLAP cube and star schema?

Code Q: Query top 5 earning employees with dept details.


 Phase 2: Oct 20 ‚Äì Dec 12 (DSA + PySpark)

Oct 20 (Mon)

DSA: Arrays basics ‚Üí Code: Reverse array | Theory: Array vs List

PySpark: Intro, RDD vs DataFrame ‚Üí Code: Load CSV | Theory: RDD vs DF


Oct 21 (Tue)

DSA: Prefix Sum ‚Üí Code: Subarray sum = k | Theory: Time complexity of prefix sum

PySpark: Transformations ‚Üí Code: Word count | Theory: Lazy evaluation


Oct 22 (Wed)

DSA: Sliding Window (fixed) ‚Üí Code: Max sum subarray k | Theory: Use case of sliding window

PySpark: Actions ‚Üí Code: Count distinct | Theory: Transformation vs Action


Oct 23 (Thu)

DSA: Sliding Window (variable) ‚Üí Code: Longest substring w/o repeat | Theory: Role of HashMap

PySpark: Joins ‚Üí Code: Inner join DFs | Theory: Broadcast vs shuffle join


Oct 24 (Fri)

DSA: Two pointers ‚Üí Code: 2-sum sorted | Theory: Two-pointer use

PySpark: Aggregations ‚Üí Code: GroupBy sum, avg | Theory: groupBy vs reduceByKey


Oct 27 (Mon)

DSA: Binary Search basics ‚Üí Code: Search rotated array | Theory: Complexity

PySpark: Window functions ‚Üí Code: Rank by salary | Theory: PartitionBy


Oct 28 (Tue)

DSA: Binary Search on Answer ‚Üí Code: Min capacity to ship | Theory: Monotonic function search

PySpark: UDF ‚Üí Code: Clean string with UDF | Theory: UDF disadvantages


Oct 29 (Wed)

DSA: Sorting ‚Üí Code: Quicksort | Theory: MergeSort vs QuickSort

PySpark: Caching ‚Üí Code: Cache DF | Theory: Cache vs Persist


Oct 30 (Thu)

DSA: Hashing basics ‚Üí Code: First non-repeating char | Theory: HashMap vs HashSet

PySpark: Partitioning ‚Üí Code: Repartition DF | Theory: Repartition vs Coalesce


Oct 31 (Fri)

DSA: Hashing apps ‚Üí Code: Subarray XOR = k | Theory: Hash collisions

PySpark: Broadcast ‚Üí Code: Broadcast join | Theory: Benefits of broadcast var


Nov 3 (Mon)

DSA: Stacks basics ‚Üí Code: Valid parentheses | Theory: Stack applications

PySpark: File formats ‚Üí Code: Read Parquet | Theory: Parquet vs CSV


Nov 4 (Tue)

DSA: Queue basics ‚Üí Code: Implement queue with stack | Theory: Queue uses

PySpark: Checkpointing ‚Üí Code: Add checkpoint | Theory: Checkpoint vs cache


Nov 5 (Wed)

DSA: Monotonic stack ‚Üí Code: Next greater element | Theory: Why monotonic stack?

PySpark: Accumulators ‚Üí Code: Count errors | Theory: When to use accumulator


Nov 6 (Thu)

DSA: Linked list basics ‚Üí Code: Reverse LL | Theory: Singly vs doubly LL

PySpark: Cluster manager ‚Üí Code: Run on local vs yarn | Theory: Spark on YARN vs Standalone


Nov 7 (Fri)

DSA: Linked list apps ‚Üí Code: Detect cycle | Theory: Floyd‚Äôs algorithm

PySpark: Data skew ‚Üí Code: Salting example | Theory: What is data skew?


Nov 10 (Mon)

DSA: Recursion basics ‚Üí Code: Factorial | Theory: Stack frame

PySpark: Catalyst optimizer ‚Üí Code: Explain plan | Theory: Role of optimizer


Nov 11 (Tue)

DSA: Recursion apps ‚Üí Code: Generate subsets | Theory: Recursion vs iteration

PySpark: Tungsten engine ‚Üí Code: Simple DF ops | Theory: Tungsten advantages


Nov 12 (Wed)

DSA: Backtracking ‚Üí Code: N-Queens | Theory: Backtracking vs brute force

PySpark: Partition tuning ‚Üí Code: Repartition before join | Theory: Shuffle partitions


Nov 13 (Thu)

DSA: Greedy basics ‚Üí Code: Activity selection | Theory: When greedy works?

PySpark: Joins perf ‚Üí Code: Broadcast join | Theory: Skew join handling


Nov 14 (Fri)

DSA: Greedy apps ‚Üí Code: Min coins change | Theory: Greedy vs DP

PySpark: Serialization ‚Üí Code: Kryo serializer | Theory: Why serialization matters?


Nov 17 (Mon)

DSA: DP basics ‚Üí Code: Fibonacci DP | Theory: Memoization vs tabulation

PySpark: Cluster tuning ‚Üí Code: Executor config | Theory: Driver vs Executor


Nov 18 (Tue)

DSA: DP arrays ‚Üí Code: Max subarray sum | Theory: Kadane‚Äôs algorithm

PySpark: Shuffle ‚Üí Code: Wide vs narrow trans | Theory: Shuffle cost


Nov 19 (Wed)

DSA: DP grid ‚Üí Code: Min path sum | Theory: DP states explanation

PySpark: AQE ‚Üí Code: Enable AQE | Theory: AQE benefits


Nov 20 (Thu)

DSA: DP subsequence ‚Üí Code: LCS | Theory: Applications of LCS

PySpark: Joins AQE ‚Üí Code: Skew join fix | Theory: AQE join strategies


Nov 21 (Fri)

DSA: DP knapsack ‚Üí Code: 0/1 Knapsack | Theory: Top-down vs bottom-up

PySpark: Partition strategy ‚Üí Code: Hash vs range partition | Theory: Pros/cons


Nov 24 (Mon)

DSA: Trees basics ‚Üí Code: Inorder traversal | Theory: BST vs Binary Tree

PySpark: Serialization deep ‚Üí Code: Kryo example | Theory: Serialization overhead


Nov 25 (Tue)

DSA: Trees DFS ‚Üí Code: Max depth | Theory: Preorder vs Postorder

PySpark: Resource tuning ‚Üí Code: Spark conf example | Theory: GC in Spark


Nov 26 (Wed)

DSA: Trees BFS ‚Üí Code: Level order traversal | Theory: BFS vs DFS usage

PySpark: Spill ‚Üí Code: Sort merge join spill | Theory: Spill to disk


Nov 27 (Thu)

DSA: Binary Tree paths ‚Üí Code: Root to leaf sum | Theory: Recursion in trees

PySpark: Checkpointing apps ‚Üí Code: Streaming checkpoint | Theory: Use cases


Nov 28 (Fri)

DSA: BST basics ‚Üí Code: Search BST | Theory: Why BST?

PySpark: Skew tuning ‚Üí Code: Salting keys | Theory: Handling skew keys


Dec 1 (Mon)

DSA: BST ops ‚Üí Code: Insert in BST | Theory: Balance in BST

PySpark: Catalyst plans ‚Üí Code: df.explain | Theory: Physical vs logical plan


Dec 2 (Tue)

DSA: Heaps basics ‚Üí Code: Heapify | Theory: Heap vs PriorityQueue

PySpark: Memory tuning ‚Üí Code: Spark conf memory | Theory: Spill prevention


Dec 3 (Wed)

DSA: Heap apps ‚Üí Code: Kth largest element | Theory: Heap use cases

PySpark: Broadcast tuning ‚Üí Code: Cache + broadcast | Theory: Perf benefits


Dec 4 (Thu)

DSA: Graph basics ‚Üí Code: BFS graph | Theory: Adj matrix vs list

PySpark: AQE partitions ‚Üí Code: Coalesce partitions | Theory: AQE coalescing


Dec 5 (Fri)

DSA: Graph DFS ‚Üí Code: Connected components | Theory: Recursion stack depth

PySpark: Shuffle deep ‚Üí Code: Map vs reduce side join | Theory: Shuffle mechanics


Dec 8 (Mon)

DSA: Graph shortest path ‚Üí Code: Dijkstra | Theory: Greedy in graphs

PySpark: Tungsten deep ‚Üí Code: Encoders | Theory: Tungsten execution


Dec 9 (Tue)

DSA: Graph MST ‚Üí Code: Kruskal | Theory: Union-Find DS

PySpark: CBO ‚Üí Code: Spark SQL with stats | Theory: Cost-based optimizer


Dec 10 (Wed)

DSA: Graph cycle ‚Üí Code: Detect cycle | Theory: Directed vs undirected cycles

PySpark: Spark SQL ‚Üí Code: Register temp table | Theory: SQL vs DF perf


Dec 11 (Thu)

DSA: Graph topological sort ‚Üí Code: Kahn‚Äôs algo | Theory: DAG in graphs

PySpark: Catalyst rule ‚Üí Code: Explain join reordering | Theory: Catalyst benefits


Dec 12 (Fri)

DSA: Graph advanced ‚Üí Code: Bellman-Ford | Theory: Neg cycle detection

PySpark: Wrap-up ‚Üí Code: Word count DF | Theory: Spark internals overview



---

üîπ Phase 3: Dec 15 ‚Äì Jan 23 (DW + Azure)

Dec 15 (Mon)

DW: Basics of OLTP vs OLAP ‚Üí Code: Star schema SQL query | Theory: OLAP vs OLTP difference

Azure: Storage intro ‚Üí Code: Upload file to Blob | Theory: Blob vs Data Lake


Dec 16 (Tue)

DW: Star vs Snowflake ‚Üí Code: Write fact-dim join | Theory: Which schema is better?

Azure: ADLS Gen2 ‚Üí Code: Mount storage in Spark | Theory: ADLS benefits


Dec 17 (Wed)

DW: Fact tables ‚Üí Code: Aggregate fact data | Theory: Fact table types

Azure: Azure SQL DB ‚Üí Code: Connect via Python | Theory: PaaS vs IaaS
[26/08, 9:25 am] anji‚ù§: Phase 3: Azure Data Engineering (Dec 18 ‚Äì Feb 27)


---

Week 13 (Dec 18 ‚Äì Dec 19)

(Short week since we start on Thursday)

Dec 18 (Thu)

Topic: Intro to Azure Data Services

Theory: Overview of Azure SQL DB, Synapse, Data Lake, Data Factory

Hands-on: Create free Azure account & explore portal


Dec 19 (Fri)

Topic: Azure Storage Accounts

Theory: Types (Blob, ADLS Gen2, Queue, Table)

Hands-on: Create a Blob container, upload/download files using Azure Portal & Python SDK



---

Week 14 (Dec 22 ‚Äì Dec 26)

Dec 22 (Mon)

Topic: Azure Data Lake Storage Gen2

Theory: Hierarchical namespace, access control (RBAC, ACL)

Hands-on: Mount ADLS in Databricks


Dec 23 (Tue)

Topic: Azure Blob Storage

Theory: Hot vs Cool vs Archive tiers

Hands-on: Lifecycle management policy


Dec 24 (Wed)

Topic: Azure Files & Queues

Theory: Use cases of File shares & Queues

Hands-on: Create queue and push messages


Dec 25 (Thu) üéÑ Holiday

Dec 26 (Fri)

Topic: Azure Data Factory (ADF) Basics

Theory: Pipelines, Linked Services, Datasets

Hands-on: Create pipeline to copy CSV ‚Üí Blob



---

Week 15 (Dec 29 ‚Äì Jan 2)

Dec 29 (Mon)

Topic: ADF Copy Activity

Theory: Integration Runtime, Data movement

Hands-on: Copy data Blob ‚Üí SQL DB


Dec 30 (Tue)

Topic: ADF Data Flows

Theory: Mapping & Wrangling data flows

Hands-on: Transform JSON ‚Üí Parquet


Dec 31 (Wed)

Topic: ADF Triggers & Monitoring

Theory: Schedule, Event, Tumbling Window triggers

Hands-on: Trigger pipeline every 1 hr


Jan 1 (Thu) üéâ Holiday

Jan 2 (Fri)

Topic: ADF Parameters & Variables

Theory: Dynamic content, pipeline reusability

Hands-on: Parametrize source/destination paths



---

Week 16 (Jan 5 ‚Äì Jan 9)

Jan 5 (Mon)

Topic: Azure Synapse Analytics ‚Äì Intro

Theory: Dedicated SQL Pool vs Serverless SQL Pool

Hands-on: Create Synapse workspace


Jan 6 (Tue)

Topic: Synapse Serverless Queries

Theory: Query Parquet/CSV files directly from Data Lake

Hands-on: Run OPENROWSET queries


Jan 7 (Wed)

Topic: Dedicated SQL Pools

Theory: Distribution methods (Round Robin, Hash, Replicated)

Hands-on: Create fact & dimension tables


Jan 8 (Thu)

Topic: Synapse Pipelines vs ADF

Theory: Similarities & differences

Hands-on: Build Synapse pipeline for ETL


Jan 9 (Fri)

Topic: Synapse Security

Theory: Row-level security, column-level security

Hands-on: Implement RLS



---

Week 17 (Jan 12 ‚Äì Jan 16)

Jan 12 (Mon)

Topic: Azure Databricks Intro

Theory: Apache Spark, Workspace setup

Hands-on: Create Databricks cluster


Jan 13 (Tue)

Topic: Databricks Notebooks

Theory: PySpark basics (DataFrame, RDD)

Hands-on: Read CSV & run transformations


Jan 14 (Wed)

Topic: Databricks & ADLS

Theory: Mounting ADLS, service principals

Hands-on: Mount ADLS to Databricks


Jan 15 (Thu)

Topic: Databricks Delta Lake

Theory: ACID transactions, Time travel

Hands-on: Create Delta table & update data


Jan 16 (Fri)

Topic: Databricks Optimizations

Theory: Caching, Partitioning, Z-Ordering

Hands-on: Optimize query performance



---

Week 18 (Jan 19 ‚Äì Jan 23)

Jan 19 (Mon)

Topic: Azure Event Hub

Theory: Event streaming basics

Hands-on: Send events from producer


Jan 20 (Tue)

Topic: Azure Stream Analytics

Theory: Real-time queries on streams

Hands-on: Write query to aggregate events in real-time


Jan 21 (Wed)

Topic: Databricks Structured Streaming

Theory: Spark streaming concepts

Hands-on: Stream data from Event Hub ‚Üí Databricks


Jan 22 (Thu)

Topic: Azure Data Lake + Streaming

Theory: Landing zones (raw, curated, trusted)

Hands-on: Store real-time data into ADLS


Jan 23 (Fri)

Topic: Kafka vs Event Hub

Theory: Differences & integration

Hands-on: Compare throughput test



---

Week 19 (Jan 26 ‚Äì Jan 30)

Jan 26 (Mon) üáÆüá≥ Holiday (Republic Day)

Jan 27 (Tue)

Topic: Azure Functions (Serverless)

Theory: Event-driven compute

Hands-on: Function to process Blob trigger


Jan 28 (Wed)

Topic: Logic Apps

Theory: Low-code workflows

Hands-on: Logic App to send email on Blob upload


Jan 29 (Thu)

Topic: Azure Key Vault

Theory: Secrets, Keys, Certificates

Hands-on: Store SQL password, access in ADF


Jan 30 (Fri)

Topic: Monitoring & Logging

Theory: Azure Monitor, Log Analytics, Alerts

Hands-on: Enable diagnostic logs for Data Factory



---

Week 20 (Feb 2 ‚Äì Feb 6)

Feb 2 (Mon)

Topic: Azure DevOps Basics

Theory: Repos, Pipelines, Boards

Hands-on: Create repo for SQL scripts


Feb 3 (Tue)

Topic: CI/CD for Data Factory

Theory: ARM templates, Git integration

Hands-on: Deploy ADF pipeline via DevOps


Feb 4 (Wed)

Topic: CI/CD for Synapse

Theory: Deployment pipelines

Hands-on: Publish Synapse artifacts via DevOps


Feb 5 (Thu)

Topic: Databricks CI/CD

Theory: Notebooks versioning & deployment

Hands-on: Use DevOps pipeline for Databricks


Feb 6 (Fri)

Topic: Infra as Code (IaC)

Theory: Bicep, Terraform

Hands-on: Deploy Storage + ADF using Bicep



---

Week 21 (Feb 9 ‚Äì Feb 13)

Feb 9 (Mon)

Topic: Azure Data Security

Theory: RBAC, Private Endpoints, Managed Identities

Hands-on: Restrict access via private endpoint


Feb 10 (Tue)

Topic: Encryption in Azure

Theory: SSE, CSE, TDE

Hands-on: Enable TDE for SQL DB


Feb 11 (Wed)

Topic: Networking in Azure

Theory: VNet, Subnets, Service Endpoints

Hands-on: Secure Synapse with VNet


Feb 12 (Thu)

Topic: Cost Management

Theory: Azure Pricing, Budgets

Hands-on: Set budget alerts


Feb 13 (Fri)

Topic: Governance

Theory: Policies, Blueprints

Hands-on: Apply policy to restrict VM size



---

Week 22 (Feb 16 ‚Äì Feb 20)

Feb 16 (Mon)

Topic: Data Modeling in Azure

Theory: Dimensional modeling (facts & dimensions)

Hands-on: Build star schema in Synapse


Feb 17 (Tue)

Topic: Slowly Changing Dimensions in Azure

Theory: Type 1, 2, 3 in Synapse/ADF

Hands-on: Implement SCD Type 2 in ADF


Feb 18 (Wed)

Topic: Performance Tuning in Azure SQL

Theory: Indexing, statistics

Hands-on: Query optimization demo


Feb 19 (Thu)

Topic: Synapse Best Practices

Theory: Partitioning, Materialized Views

Hands-on: Partition large fact table


Feb 20 (Fri)

Topic: Data Lake Best Practices

Theory: Naming conventions, folder structure

Hands-on: Design folder structure for Data Lake



---

Week 23 (Feb 23 ‚Äì Feb 27)

Feb 23 (Mon)

Topic: Power BI with Azure

Theory: DirectQuery vs Import from Synapse

Hands-on: Connect Power BI to Synapse


Feb 24 (Tue)

Topic: Power BI with Databricks

Theory: Lakehouse integration

Hands-on: Connect Power BI to Delta Lake


Feb 25 (Wed)

Topic: End-to-End Project Discussion

Theory: Batch + Streaming + Reporting

Hands-on: Design project architecture


Feb 26 (Thu)

Topic: End-to-End Project Implementation (Part 1)

Hands-on: Ingest data ‚Üí Transform ‚Üí Store in Synapse


Feb 27 (Fri)

Topic: End-to-End Project Implementation (Part 2)
