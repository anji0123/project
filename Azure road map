Sql advanced with notes
Data warehouse concepts
Aure real time project videos
Azure classes playlist
Pyspark classes or course
Python basics(teams videos) 
Power bi classes ( teams videos) 
Big data 9hours video

Hands-on: Stream + Batch + Power BI dashboaüìÖ
 Phase 1 (Python + SQL) ‚Üí Aug 25 ‚Äì Oct 17


---

Week 1

Aug 25 (Mon)

Python: Variables & Data Types

Theory Q: What is the difference between mutable and immutable types in Python?

Code Q: Reverse a string without using slicing.


SQL: SELECT, WHERE

Theory Q: Difference between WHERE and HAVING clause?

Code Q: Query employees with salary > 50,000.



Aug 26 (Tue)

Python: Lists & Tuples

Theory Q: Why is a tuple faster than a list in Python?

Code Q: Find the 2nd largest number in a list.


SQL: ORDER BY, DISTINCT

Theory Q: What is the use of DISTINCT?

Code Q: Query top 3 highest salaries.



Aug 27 (Wed)

Python: Dictionaries & Sets

Theory Q: Why dictionary is faster than list for lookups?

Code Q: Count word frequency in a string.


SQL: Aggregate Functions

Theory Q: Difference between COUNT(*) and COUNT(column)?

Code Q: Find average salary per department.



Aug 28 (Thu)

Python: If-else, Loops

Theory Q: Difference between while and for loop?

Code Q: Check if a number is prime.


SQL: GROUP BY, HAVING

Theory Q: Why can‚Äôt we use WHERE with aggregate functions?

Code Q: Find departments with avg salary > 60k.



Aug 29 (Fri)

Python: Functions

Theory Q: What are default arguments in Python functions?

Code Q: Fibonacci series using recursion.


SQL: JOINS (INNER)

Theory Q: Difference between INNER JOIN and EQUIJOIN?

Code Q: Query employees with their department names.




---

Week 2

Sep 1 (Mon)

Python: Lambda, map, filter, reduce

Theory Q: When to use lambda vs def?

Code Q: Square all numbers in a list using map.


SQL: LEFT JOIN

Theory Q: Difference between LEFT JOIN and INNER JOIN?

Code Q: List all employees and their dept (even if dept missing).

                                                                    üêç Python: List Comprehension
                                                                    ‚úÖ Theory Q: What is the advantage of list comprehension?
                                                                    List comprehension is a concise way to create lists in Python. Instead of using loops, you write everything in a single line.
                                                                    
                                                                    üîπ Advantages:
                                                                    Cleaner syntax: Easier to read and write
                                                                    
                                                                    Faster execution: Optimized under the hood
                                                                    
                                                                    More Pythonic: Preferred in interviews and real codebases
                                                                    
                                                                    üí° Example comparison:
                                                                    
                                                                    python
                                                                    # Traditional loop
                                                                    evens = []
                                                                    for i in range(50):
                                                                        if i % 2 == 0:
                                                                            evens.append(i)
                                                                    
                                                                    # List comprehension
                                                                    evens = [i for i in range(50) if i % 2 == 0]
                                                                    üßÆ Code Q: Generate even numbers less than 50
                                                                    python
                                                                    even_numbers = [i for i in range(50) if i % 2 == 0]
                                                                    print(even_numbers)
                                                                    üîç Output: [0, 2, 4, 6, ..., 48]
                                                                    
                                                                    üóÉÔ∏è SQL: RIGHT JOIN
                                                                    ‚úÖ Theory Q: Difference between LEFT JOIN and RIGHT JOIN?
                                                                    Join Type	Description
                                                                    LEFT JOIN	Returns all rows from the left table, and matched rows from the right
                                                                    RIGHT JOIN	Returns all rows from the right table, and matched rows from the left
                                                                    üí° Think of it like this:
                                                                    
                                                                    LEFT JOIN = ‚ÄúGive me everything from Table A, even if Table B is missing‚Äù
                                                                    
                                                                    RIGHT JOIN = ‚ÄúGive me everything from Table B, even if Table A is missing‚Äù
                                                                    
                                                                    üßÆ Code Q: List all departments and employees (even if employee missing)
                                                                    Assume two tables:
                                                                    
                                                                    sql
                                                                    Departments
                                                                    -----------
                                                                    DeptID | DeptName
                                                                       1   | HR
                                                                       2   | IT
                                                                       3   | Finance
                                                                    
                                                                    Employees
                                                                    ----------
                                                                    EmpID | EmpName | DeptID
                                                                     101  | Alice   | 1
                                                                     102  | Bob     | 2
                                                                    üîπ SQL Query:
                                                                    sql
                                                                    SELECT d.DeptName, e.EmpName
                                                                    FROM Employees e
                                                                    RIGHT JOIN Departments d ON e.DeptID = d.DeptID;
                                                                    üîç Output:
                                                                    
                                                                    Code
                                                                    DeptName | EmpName
                                                                    HR       | Alice
                                                                    IT       | Bob
                                                                    Finance  | NULL   -- No employee in Finance
                                                                    üß† How to Use This in Interviews
                                                                    When asked:
                                                                    
                                                                    ‚ÄúWhat‚Äôs the difference between LEFT and RIGHT JOIN?‚Äù
                                                                    
                                                                    You say:
                                                                    
                                                                    ‚ÄúLEFT JOIN keeps all rows from the left table, RIGHT JOIN keeps all rows from the right. For example, if I want to list all departments even if no employee is assigned, I‚Äôd use RIGHT JOIN.‚Äù
                                                                    
                                                                    When asked:
                                                                    
                                                                    ‚ÄúHow do you generate even numbers in Python?‚Äù
                                                                    
                                                                    You say:
                                                                    
                                                                    ‚ÄúI‚Äôd use list comprehension for cleaner syntax: [i for i in range(50) if i % 2 == 0].‚Äù
                                                                    
                                                                    Sep 2 (Tue)
                                                                    
                                                                    Python: List comprehension
                                                                    
                                                                    Theory Q: Advantage of list comprehension?
                                                                    
                                                                    Code Q: Generate even numbers < 50.
                                                                    
                                                                    
                                                                    SQL: RIGHT JOIN
                                                                    
                                                                    Theory Q: Difference between LEFT and RIGHT join?
                                                                    
                                                                    Code Q: List all departments and employees (even if employee missing).



Sep 3 (Wed)

Python: Error handling (try, except)

Theory Q: Difference between Exception and Error in Python?

Code Q: Handle division by zero gracefully.

SQL: FULL OUTER JOIN
                                                                     
Theory Q: When to use FULL OUTER JOIN?
                                                                     
Code Q: List all employees and all departments.
                                                                     üêç PYTHON: Error Handling (try, except)
                                                                     üîπ What is Error Handling?
                                                                     Imagine you're driving a car and suddenly a pothole appears. Instead of crashing, you slow down and steer around it. That‚Äôs what error handling does in code‚Äîit prevents your program from crashing when something unexpected happens.
                                                                     
                                                                     ‚úÖ What‚Äôs the Difference Between Error and Exception?
                                                                     Term	Meaning	Can be handled?
                                                                     Error	Serious issues like syntax mistakes or memory overflow	‚ùå No
                                                                     Exception	Runtime problems like dividing by zero or missing files	‚úÖ Yes
                                                                     Examples:
                                                                     
                                                                     SyntaxError: You forgot a colon or bracket ‚Üí Error
                                                                     
                                                                     ZeroDivisionError: You tried dividing by 0 ‚Üí Exception
                                                                     
                                                                     üîπ Why Use try and except?
                                                                     To catch exceptions and respond gracefully.
                                                                     
                                                                     ‚úÖ Syntax:
                                                                     python
                                                                     try:
                                                                         # risky code
                                                                     except ExceptionType:
                                                                         # what to do if error happens
                                                                     üß™ Code Example: Division by Zero
                                                                     python
                                                                     try:
                                                                         a = int(input("Enter numerator: "))
                                                                         b = int(input("Enter denominator: "))
                                                                         result = a / b
                                                                         print("Result:", result)
                                                                     except ZeroDivisionError:
                                                                         print("Oops! You can't divide by zero.")
                                                                     except ValueError:
                                                                         print("Please enter valid numbers.")
                                                                     üîç Explanation:
                                                                     try: Runs the code that might fail
                                                                     
                                                                     except ZeroDivisionError: Catches division by zero
                                                                     
                                                                     except ValueError: Catches non-numeric input
                                                                     
                                                                     Program keeps running instead of crashing
                                                                     
                                                                     üß† Bonus: finally and else
                                                                     finally: Runs no matter what, even if there‚Äôs an error
                                                                     
                                                                     else: Runs only if no error occurs
                                                                     
                                                                     python
                                                                     try:
                                                                         print("Trying...")
                                                                         x = 1 / 1
                                                                     except:
                                                                         print("Error occurred")
                                                                     else:
                                                                         print("No error!")
                                                                     finally:
                                                                         print("Always runs")
                                                                     üõ¢Ô∏è SQL: FULL OUTER JOIN
                                                                     üîπ What is a JOIN?
                                                                     A JOIN connects two tables based on a common column‚Äîlike matching employee IDs with department IDs.
                                                                     
                                                                     ‚úÖ Types of JOINs
                                                                     JOIN Type	What It Shows
                                                                     INNER JOIN	Only matching rows from both tables
                                                                     LEFT JOIN	All rows from left + matched from right
                                                                     RIGHT JOIN	All rows from right + matched from left
                                                                     FULL OUTER JOIN	All rows from both tables, matched or not
                                                                     üîç FULL OUTER JOIN Explained
                                                                     Imagine two circles:
                                                                     
                                                                     One for employees
                                                                     
                                                                     One for departments
                                                                     
                                                                     A FULL OUTER JOIN gives you everything in both circles, even if there‚Äôs no match.
                                                                     
                                                                     üß™ Code Example: List All Employees and All Departments
                                                                     sql
                                                                     SELECT e.name, d.department_name
                                                                     FROM employees e
                                                                     FULL OUTER JOIN departments d
                                                                     ON e.department_id = d.id;
                                                                     ‚úÖ What This Does:
                                                                     Shows employees with departments
                                                                     
                                                                     Shows departments with no employees
                                                                     
                                                                     Shows employees without departments
                                                                     
                                                                     Fills missing values with NULL
                                                                     
                                                                     üß† Real-Life Analogy
                                                                     Think of a school:
                                                                     
                                                                     Some students are assigned to classes
                                                                     
                                                                     Some classes have no students
                                                                     
                                                                     Some students haven‚Äôt been assigned yet
                                                                     
                                                                     A FULL OUTER JOIN shows everyone and every class, even if they‚Äôre not connected.
                                                                     
                                                                     üéì Summary for Sep 3 (Wed)
                                                                     Topic	What You Learned
                                                                     Python Error Handling	Use try, except, finally, else to manage runtime issues
                                                                     Exception vs Error	Exceptions can be caught; errors usually crash
                                                                     Division by Zero	Catch with ZeroDivisionError
                                                                     SQL FULL OUTER JOIN	Combines all rows from both tables, even unmatched ones
                                                                     Use Case	Great for audits, completeness checks, and data reconciliation
                                                                     
                                                               
                                                                     
                                                                     

Sep 4 (Thu)

Python: File Handling

Theory Q: Modes of opening files in Python?

Code Q: Count number of lines in a file.

SQL: UNION vs UNION ALL

Theory Q: Difference between UNION and UNION ALL?

Code Q: Combine employee names from two tables removing duplicates.

explain each and every term and all the stuff related to this concepts for thoery 
and practical wise even for a kid to understand 
and shoould also cover INterview point of view for a azure data engineer in 5/3 bank


                                                           üêç PYTHON: File Handling

                                                                 r for read 
                                                                 w for overwrite 
                                                                 x for write if not exist 
                                                                 a for append at end and also creates if not exist 
                                                                 wb and rb for read and write binary 
                                                                 r+ is to read and write and at position(file must exist)

                                                           üìò Theory: Modes of Opening Files in Python
                                                           When you open a file using open(), you tell Python what you want to do with that file. That‚Äôs called the mode.
                                                           
                                                           Mode	Description	Interview Insight
                                                           'r'	Read mode (default). Opens file for reading. Fails if file doesn‚Äôt exist.	Used in ETL pipelines to read config or data files.
                                                           'w'	Write mode. Creates file or overwrites existing one.	Used to write logs or export data. Risk: overwrites existing files.
                                                           'a'	Append mode. Adds content to end of file.	Good for logging without losing previous entries.
                                                           'x'	Exclusive creation. Fails if file exists.	Used when you want to ensure no overwrite happens.
                                                           'b'	Binary mode. For non-text files (images, PDFs).	Used in secure data transfers or encryption.
                                                           't'	Text mode. Default for reading/writing strings.	Most common for CSV, TXT, JSON files.
                                                           'r+'	Read and write. Doesn‚Äôt truncate file.	Useful for updating config files or audit logs.
                                                           üí° Real-world tip: In banking, file handling is often used to process batch files, audit logs, or secure data exports. You must handle files safely to avoid data loss or compliance issues.
                                                           
                                                           üß™ Code: Count Number of Lines in a File
                                                           python
                                                           def count_lines(filename):
                                                               try:
                                                                   with open(filename, 'r') as f:
                                                                       lines = f.readlines()
                                                                       return len(lines)
                                                               except FileNotFoundError:
                                                                   print("File not found.")
                                                               except Exception as e:
                                                                   print("Error:", e)
                                                           
                                                           # Example usage
                                                           print(count_lines("transactions.txt"))
                                                           ‚úÖ Explanation:
                                                           open(filename, 'r'): Opens file in read mode
                                                           
                                                           readlines(): Reads all lines into a list
                                                           
                                                           len(lines): Counts how many lines
                                                           
                                                           try-except: Handles missing file or other errors
                                                           
                                                           üí° Interview angle: You might be asked how to process large files efficiently. In that case, use a loop:
                                                           
                                                           python
                                                           count = 0
                                                           with open(filename, 'r') as f:
                                                               for _ in f:
                                                                   count += 1
                                                           This avoids loading the whole file into memory‚Äîimportant for big data!
                                                           
                                                           üõ¢Ô∏è SQL: UNION vs UNION ALL
                                                           üìò Theory: What‚Äôs the Difference?
                                                           Clause	What It Does	Interview Insight
                                                           UNION	Combines results from two queries and removes duplicates	Good for clean reporting or deduplicated dashboards
                                                           UNION ALL	Combines results and keeps duplicates	Faster and better for raw data aggregation or audit logs
                                                           üí° Real-world tip: In banking, you often merge data from multiple systems (e.g., loan and credit card systems). Use UNION when duplicates are bad (e.g., customer reports), and UNION ALL when you want full traceability.
                                                           
                                                           üß™ Code: Combine Employee Names from Two Tables (Remove Duplicates)
                                                           sql
                                                           SELECT name FROM employees_us
                                                           UNION
                                                           SELECT name FROM employees_india;
                                                           ‚úÖ Explanation:
                                                           Combines names from both tables
                                                           
                                                           Removes duplicates automatically
                                                           
                                                           If you want to keep duplicates, use UNION ALL
                                                           
                                                           üí° Interview angle: You may be asked:
                                                           
                                                           How does UNION affect performance? (Answer: slower due to deduplication)
                                                           
                                                           How do you handle schema mismatch? (Answer: columns must match in number and type)
                                                           
                                                           üß† How This Applies to Azure Data Engineering at 5/3 Bank
                                                           üîπ File Handling
                                                           You‚Äôll work with Azure Data Lake, Blob Storage, or Synapse Pipelines that read/write files.
                                                           
                                                           You must know how to handle file formats (CSV, JSON, Parquet), manage access, and avoid overwriting sensitive data.
                                                           
                                                           üîπ SQL UNION
                                                           You‚Äôll often write SQL queries in Synapse or Databricks to merge data from multiple sources.
                                                           
                                                           In banking, this could mean combining customer data, transaction logs, or compliance reports.
                                                           
                                                           Understanding UNION vs UNION ALL helps you control data quality, performance, and auditability.
                                                           
                                                           üéì Summary
                                                           Concept	What You Learned	Real-World Relevance
                                                           Python File Modes	'r', 'w', 'a', 'x', 'b', 't', 'r+'	Used in ETL, logging, secure file handling
                                                           Line Counting	readlines() vs loop	Efficient file processing
                                                           SQL UNION	Removes duplicates	Clean reporting
                                                           SQL UNION ALL	Keeps duplicates	Raw data aggregation
                                                           Interview Focus	Performance, deduplication, schema matching	Critical for banking data pipelines


Sep 5 (Fri)

Python: OOP ‚Äì Classes & Objects

Theory Q: What is init in Python?

Code Q: Create a Student class with attributes and display details.


SQL: Subqueries

Theory Q: Difference between correlated and non-correlated subquery?

Code Q: Find employees whose salary > average salary.

                                                               üêç PYTHON: OOP ‚Äì Classes & Objects
                                                               ‚úÖ Theory Q: What is __init__ in Python?
                                                               __init__ is a special method in Python called a constructor. It runs automatically when you create an object from a class.
                                                               
                                                               üîç Think of it like this:
                                                               Imagine a class is a blueprint for building a robot. The __init__ method is the setup button that gives each robot its name, color, and size when it‚Äôs built.
                                                               
                                                               üìò Technical Explanation:
                                                               __init__ is used to initialize attributes of an object.
                                                               
                                                               It always takes self as the first parameter (which refers to the object itself).
                                                               
                                                               You can pass other parameters to set values like name, age, etc.
                                                               
                                                               üß† Interview Tip:
                                                               If asked ‚ÄúWhat does __init__ do?‚Äù, say:
                                                               
                                                               ‚ÄúIt‚Äôs the constructor method that initializes object attributes when a class instance is created. It helps set up the object‚Äôs internal state.‚Äù
                                                               
                                                               üíª Code Q: Create a Student class with attributes and display details
                                                               python
                                                               class Student:
                                                                   def __init__(self, name, roll_number, age, grade):
                                                                       self.name = name
                                                                       self.roll_number = roll_number
                                                                       self.age = age
                                                                       self.grade = grade
                                                               
                                                                   def display_details(self):
                                                                       print("Student Name:", self.name)
                                                                       print("Roll Number:", self.roll_number)
                                                                       print("Age:", self.age)
                                                                       print("Grade:", self.grade)
                                                               
                                                               # Creating an object
                                                               student1 = Student("Anji", 101, 22, "A")
                                                               student1.display_details()
                                                               üß† Interview Tip:
                                                               Explain how self binds the attributes to the object, and how methods like display_details() allow encapsulated access to data.
                                                               
                                                               üßÆ SQL: Subqueries
                                                               ‚úÖ Theory Q: Difference Between Correlated and Non-Correlated Subqueries
                                                               Feature	Non-Correlated Subquery	Correlated Subquery
                                                               Dependency	Independent of outer query	Depends on outer query
                                                               Execution	Runs once	Runs for every row in outer query
                                                               Performance	Faster	Slower due to repeated execution
                                                               Use Case	Aggregate comparisons, filtering	Row-by-row filtering, conditional logic
                                                               Example Use	Compare salary to overall average	Compare salary to department average
                                                               üß† Think of it like this:
                                                               Non-Correlated: Like checking the average score of the whole class once.
                                                               
                                                               Correlated: Like checking if each student scored above their own section‚Äôs average.
                                                               
                                                               üíª Code Q: Find employees whose salary > average salary
                                                               ‚úÖ Non-Correlated Subquery Example:
                                                               sql
                                                               SELECT employee_name, salary
                                                               FROM employees
                                                               WHERE salary > (SELECT AVG(salary) FROM employees);
                                                               SELECT AVG(salary) runs once and returns a single value.
                                                               
                                                               The outer query compares each employee‚Äôs salary to that value.
                                                               
                                                               ‚úÖ Correlated Subquery Example (by department):
                                                               sql
                                                               SELECT employee_name, salary, department_id
                                                               FROM employees e
                                                               WHERE salary > (
                                                                   SELECT AVG(salary)
                                                                   FROM employees
                                                                   WHERE department_id = e.department_id
                                                               );
                                                               The subquery runs for each employee, calculating the average salary of their department.
                                                               
                                                               This is useful in banking analytics to compare performance or detect anomalies.
                                                               
                                                               üß† Interview Tip for Azure Data Engineer at Fifth Third Bank:
                                                               ‚ÄúIn fraud analytics, I‚Äôve used correlated subqueries to compare transaction amounts against customer-specific averages. For example, flagging transactions that exceed a customer‚Äôs typical spend pattern. In Azure Synapse or SQL Server, I optimize these queries using indexed views or materialized results when performance is critical.‚Äù
                                                               
                                                               üß© Summary for Interviews
                                                               Concept	What to Say in Interviews
                                                               __init__	‚ÄúIt‚Äôs the constructor that initializes object attributes when an instance is created.‚Äù
                                                               Student Class	‚ÄúI used OOP to encapsulate student data and methods for clean, reusable code.‚Äù
                                                               Subqueries	‚ÄúI understand both correlated and non-correlated subqueries and use them for analytics.‚Äù
                                                               Real-World Use	‚ÄúAt Fifth Third Bank, I used SQL subqueries to compare transaction patterns and detect fraud.‚Äù



---

Week 3

Sep 8 (Mon)

Python: OOP ‚Äì Inheritance

Theory Q: What is multiple inheritance? How does Python handle it?

Code Q: Demonstrate single & multiple inheritance with classes.


SQL: EXISTS & IN

Theory Q: Difference between IN and EXISTS?

Code Q: Find employees working in departments that exist in dept table.

in the same way explain each and every concept related to these along with heading 
and make sure this covers all the topics related to these in any interviewer POV no matter how hard the interview maybe 
and also give real time usecase of my client 5/3 bank

                                                                       
                                                                       üêç Python OOP ‚Äì Inheritance
                                                                       üîç What Is Inheritance?
                                                                       Inheritance is a core concept in Object-Oriented Programming (OOP) where a class (child) can inherit attributes and methods from another class (parent). It promotes code reuse, modularity, and scalability.
                                                                       
                                                                       üß† Types of Inheritance in Python
                                                                       Type	Description
                                                                       Single Inheritance	One child class inherits from one parent class.
                                                                       Multiple Inheritance	One child class inherits from more than one parent class.
                                                                       Multilevel Inheritance	A class inherits from a class that itself inherits from another class.
                                                                       Hierarchical Inheritance	Multiple child classes inherit from a single parent class.
                                                                       Hybrid Inheritance	A combination of multiple types of inheritance.
                                                                       üîç What Is Multiple Inheritance?
                                                                       A class inherits from two or more parent classes.
                                                                       
                                                                       Python supports this directly using the syntax: class Child(Parent1, Parent2):
                                                                       
                                                                       Python uses Method Resolution Order (MRO) to resolve conflicts when multiple parents have methods with the same name.
                                                                       
                                                                       ‚ö†Ô∏è Diamond Problem
                                                                       Occurs when multiple paths lead to the same base class. Python resolves this using C3 Linearization (MRO).
                                                                       
                                                                       python
                                                                       class A:
                                                                           def show(self):
                                                                               print("A")
                                                                       
                                                                       class B(A):
                                                                           def show(self):
                                                                               print("B")
                                                                       
                                                                       class C(A):
                                                                           def show(self):
                                                                               print("C")
                                                                       
                                                                       class D(B, C):
                                                                           pass
                                                                       
                                                                       d = D()
                                                                       d.show()  # Output: B (MRO chooses B over C)
                                                                       üíª Code Examples
                                                                       ‚úÖ Single Inheritance
                                                                       python
                                                                       class Bank:
                                                                           def bank_name(self):
                                                                               print("Fifth Third Bank")
                                                                       
                                                                       class Employee(Bank):
                                                                           def emp_details(self):
                                                                               print("Data Engineer")
                                                                       
                                                                       e = Employee()
                                                                       e.bank_name()
                                                                       e.emp_details()
                                                                       ‚úÖ Multiple Inheritance
                                                                       python
                                                                       class AzureSkills:
                                                                           def azure(self):
                                                                               print("Azure Data Factory, Synapse")
                                                                       
                                                                       class PythonSkills:
                                                                           def python(self):
                                                                               print("Python, PySpark")
                                                                       
                                                                       class DataEngineer(AzureSkills, PythonSkills):
                                                                           def role(self):
                                                                               print("Azure Data Engineer")
                                                                       
                                                                       de = DataEngineer()
                                                                       de.azure()
                                                                       de.python()
                                                                       de.role()
                                                                       üßë‚Äçüíº Real-Time Use Case @ 5/3 Bank
                                                                       ‚ÄúWe use multiple inheritance to build modular ETL components. For example, one class handles Azure Synapse connectivity, another handles PySpark transformations, and a third class inherits both to orchestrate the full pipeline.‚Äù
                                                                       
                                                                 1. Stateless Logger (No __init__)
                                                                 python
                                                                 class Logger:
                                                                     def log(self, message):
                                                                         print("Log:", message)
                                                                 
                                                                 job = Logger()
                                                                 job.log("Pipeline started")  # ‚úÖ Message passed at method call
                                                                 2. Stateful Logger (With __init__)
                                                                 python
                                                                 class Logger:
                                                                     def __init__(self, message):
                                                                         self.message = message
                                                                 
                                                                     def log(self):
                                                                         print("Log:", self.message)
                                                                 
                                                                 job = Logger("Pipeline started")  # ‚úÖ Message stored at object creation
                                                                 job.log()
                                                                       üóÉÔ∏è SQL ‚Äì EXISTS vs IN
                                                                       üîç Theory: Difference Between IN and EXISTS
                                                                       Feature	IN	EXISTS
                                                                       Purpose	Checks if a value exists in a list	Checks if a subquery returns any rows
                                                                       Execution	Subquery runs once	Subquery runs for each row in outer query
                                                                       Performance	Better for small datasets	Better for large datasets
                                                                       NULL Handling	May fail with NULLs	Handles NULLs gracefully
                                                                       Use Case	Static lists or small subqueries	Dynamic existence checks
                                                                       üíª Code: Find Employees in Valid Departments
                                                                       ‚úÖ Using IN
                                                                       sql
                                                                       SELECT employee_id, name
                                                                       FROM employees
                                                                       WHERE department_id IN (
                                                                           SELECT department_id FROM departments
                                                                       );
                                                                       ‚úÖ Using EXISTS
                                                                       sql
                                                                       SELECT e.employee_id, e.name
                                                                       FROM employees e
                                                                       WHERE EXISTS (
                                                                           SELECT 1
                                                                           FROM departments d
                                                                           WHERE d.department_id = e.department_id
                                                                       );
                                                                       üßë‚Äçüíº Real-Time Use Case @ 5/3 Bank
                                                                       ‚ÄúWe use EXISTS in Azure SQL Database to validate employee records against active departments. This ensures data integrity during ETL loads. For example, before syncing HR data to Synapse, we check if the department exists using EXISTS to avoid orphan records.‚Äù
                                                                       
                                                                       üß† Interview-Ready Insights
                                                                       üîπ Python Inheritance
                                                                       Be ready to explain MRO and the diamond problem.
                                                                       
                                                                       Use real-world analogies like ‚Äúinheritance in a family tree.‚Äù
                                                                       
                                                                       Mention how you modularize ETL logic using class hierarchies.
                                                                       
                                                                       üîπ SQL EXISTS vs IN
                                                                       Know when to use each based on dataset size.
                                                                       
                                                                       Be prepared to discuss performance implications in Azure Synapse.
                                                                       
                                                                       Mention how you use these in data validation and governance.
                                                                       
                                                                       üß© Bonus: How to Extend These Concepts
                                                                       Use Python inheritance to build custom logging, error handling, or data connectors.
                                                                       
                                                                       Use SQL EXISTS in data quality checks, referential integrity, or access control filters.
Sep 9 (Tue)

Python: OOP ‚Äì Polymorphism

Theory Q: What is method overriding?

Code Q: Implement method overriding with Animal ‚Üí Dog class.


SQL: ANY & ALL

Theory Q: Difference between ANY and ALL operators?

Code Q: Find employees earning more than ALL employees in dept 10.



Sep 10 (Wed)

Python: OOP ‚Äì Encapsulation

Theory Q: What is the purpose of private variables in Python?

Code Q: Create a BankAccount class with deposit & withdraw methods.


SQL: CASE statement

Theory Q: When do we use CASE in SQL?

Code Q: Show employees with grade ‚ÄòHigh‚Äô if salary > 70k else ‚ÄòLow‚Äô.



Sep 11 (Thu)

Python: OOP ‚Äì Abstraction

Theory Q: What is an abstract class in Python?

Code Q: Create an abstract class Vehicle with method drive().


SQL: Stored Procedures (Intro)

Theory Q: Difference between procedure and function?

Code Q: Write a procedure to increase all salaries by 10%.



Sep 12 (Fri)

Python: Modules & Packages

Theory Q: Difference between module and package in Python?

Code Q: Create a package with math utilities and import it.


SQL: Functions in SQL

Theory Q: Difference between scalar and table-valued functions?

Code Q: Write a function to return total salary of a department.




---

Week 4

Sep 15 (Mon)

Python: Iterators & Generators

Theory Q: Difference between iterator and generator?

Code Q: Write a generator for Fibonacci numbers.


SQL: Indexing

Theory Q: Difference between clustered and non-clustered index?

Code Q: Create an index on salary column.



Sep 16 (Tue)

Python: Decorators

Theory Q: What are decorators in Python?

Code Q: Create a decorator to log function execution time.


SQL: Views

Theory Q: Advantages of using views?

Code Q: Create a view showing employee name and dept.



Sep 17 (Wed)

Python: Itertools

Theory Q: What is itertools used for?

Code Q: Use itertools to generate all permutations of a list.


SQL: CTEs

Theory Q: Difference between CTE and subquery?

Code Q: Use CTE to calculate running total of salaries.



Sep 18 (Thu)

Python: Collections Module

Theory Q: What is Counter in collections?

Code Q: Count character frequency in a string using Counter.


SQL: Window Functions (ROW_NUMBER)

Theory Q: Difference between RANK, DENSE_RANK, ROW_NUMBER?

Code Q: Assign row numbers to employees ordered by salary.



Sep 19 (Fri)

Python: Multithreading

Theory Q: Difference between multithreading and multiprocessing?

Code Q: Create two threads printing even & odd numbers separately.


SQL: Window Functions (RANK, DENSE_RANK)

Theory Q: Difference between RANK and DENSE_RANK?

Code Q: Find top 3 earners in each department.




---

Week 5

Sep 22 (Mon)

Python: Multiprocessing

Theory Q: When to use multiprocessing instead of multithreading?

Code Q: Use multiprocessing to calculate squares of a list.


SQL: PARTITION BY

Theory Q: Difference between GROUP BY and PARTITION BY?

Code Q: Find running total of salary partitioned by dept.



Sep 23 (Tue)

Python: Virtual Environments

Theory Q: Why do we use virtualenv in Python?

Code Q: Create a virtual environment and install pandas.


SQL: Common Aggregations with Window

Theory Q: Difference between SUM() OVER and SUM() with GROUP BY?

Code Q: Show cumulative salary by employee order.



Sep 24 (Wed)

Python: Pip & Package Management

Theory Q: Difference between pip and conda?

Code Q: Install numpy and check version in code.


SQL: Recursive CTE

Theory Q: What is a recursive CTE?

Code Q: Print hierarchy of employees under a manager.



Sep 25 (Thu)

Python: JSON Handling

Theory Q: Difference between json.load() and json.loads()?

Code Q: Parse a JSON file of employee records.


SQL: Transactions

Theory Q: ACID properties in SQL?

Code Q: Demonstrate BEGIN, COMMIT, ROLLBACK.



Sep 26 (Fri)

Python: Regex Basics

Theory Q: What are greedy vs non-greedy regex?

Code Q: Extract all emails from a text.


SQL: Triggers

Theory Q: What is a trigger in SQL?

Code Q: Create a trigger to log updates on salary.




---

Week 6

Sep 29 (Mon)

Python: Advanced Regex

Theory Q: What is the use of lookahead and lookbehind in regex?

Code Q: Extract all numbers from a string using regex.


SQL: Normalization (1NF‚Äì3NF)

Theory Q: What is difference between 2NF and 3NF?

Code Q: Normalize a sample employee table to 3NF.



Sep 30 (Tue)

Python: Date & Time

Theory Q: Difference between datetime.now() and utcnow()?

Code Q: Print current date in YYYY-MM-DD format.


SQL: Denormalization

Theory Q: When is denormalization used?

Code Q: Merge dept and employee table into a denormalized view.



Oct 1 (Wed)

Python: Logging

Theory Q: Why use logging instead of print()?

Code Q: Write logs to file with timestamp.


SQL: Stored Procedures Advanced

Theory Q: Can stored procedures return multiple result sets?

Code Q: Procedure to fetch top N salaries by dept.



Oct 2 (Thu)

Python: Unit Testing

Theory Q: What is unittest in Python?

Code Q: Write unittest for add(a, b).


SQL: Functions Advanced

Theory Q: Difference between deterministic and non-deterministic function?

Code Q: Write function to calculate factorial.



Oct 3 (Fri)

Python: Itertools Advanced

Theory Q: What is product() in itertools?

Code Q: Generate cartesian product of two lists.


SQL: Index Optimization

Theory Q: When does index slow down performance?

Code Q: Create composite index on (dept, salary).




---

Week 7

Oct 6 (Mon)

Python: CSV Handling

Theory Q: Difference between csv.reader and csv.DictReader?

Code Q: Read CSV and calculate column sum.


SQL: Temp Tables

Theory Q: Difference between temp table and table variable?

Code Q: Create a temp table for employees with salary > 70k.



Oct 7 (Tue)

Python: Pandas Intro

Theory Q: Difference between Series and DataFrame?

Code Q: Read CSV into DataFrame and show first 5 rows.


SQL: Optimization Basics

Theory Q: How to check execution plan in SQL?

Code Q: Compare query with and without index.



Oct 8 (Wed)

Python: Pandas Indexing

Theory Q: Difference between loc and iloc?

Code Q: Select all employees with salary > 50k using pandas.


SQL: Query Tuning

Theory Q: Difference between nested loop and hash join?

Code Q: Rewrite slow query using join optimization.



Oct 9 (Thu)

Python: Pandas GroupBy

Theory Q: Difference between groupby() and pivot_table()?

Code Q: Find average salary per dept in pandas.


SQL: Materialized Views

Theory Q: Difference between normal view and materialized view?

Code Q: Create materialized view of dept salaries.



Oct 10 (Fri)

Python: Pandas Merge & Join

Theory Q: Difference between merge and join in pandas?

Code Q: Merge employees with dept DataFrame.


SQL: Partition Tables

Theory Q: Why partition a table?

Code Q: Partition employees table by dept.




---

Week 8

Oct 13 (Mon)

Python: Numpy Basics

Theory Q: Difference between numpy array and Python list?

Code Q: Create numpy array and calculate mean.


SQL: OLAP vs OLTP

Theory Q: Difference between OLAP and OLTP?

Code Q: Show example schema for OLAP.



Oct 14 (Tue)

Python: Numpy Indexing & Slicing

Theory Q: Difference between shallow copy and deep copy in numpy?

Code Q: Slice numpy array into 2 halves.


SQL: Fact & Dimension Tables

Theory Q: Difference between fact and dimension tables?

Code Q: Design star schema with employee and dept.



Oct 15 (Wed)

Python: Numpy Operations

Theory Q: Difference between broadcasting and vectorization?

Code Q: Multiply two numpy arrays element-wise.


SQL: Slowly Changing Dimensions

Theory Q: Difference between SCD Type 1 and Type 2?

Code Q: Create SQL script for SCD Type 2 on employee table.



Oct 16 (Thu)

Python: Numpy Aggregations

Theory Q: What are axis parameters in numpy?

Code Q: Find sum across rows of 2D numpy array.


SQL: Data Warehousing Basics

Theory Q: Difference between star and snowflake schema?

Code Q: Write query for sales fact joining product dimension.



Oct 17 (Fri)

Python: Final Revision + Mini Mock

Theory Q: Explain Python memory management.

Code Q: Write function to check if string is palindrome.


SQL: Final Revision + Mini Mock

Theory Q: Difference between OLAP cube and star schema?

Code Q: Query top 5 earning employees with dept details.


 Phase 2: Oct 20 ‚Äì Dec 12 (DSA + PySpark)

Oct 20 (Mon)

DSA: Arrays basics ‚Üí Code: Reverse array | Theory: Array vs List

PySpark: Intro, RDD vs DataFrame ‚Üí Code: Load CSV | Theory: RDD vs DF


Oct 21 (Tue)

DSA: Prefix Sum ‚Üí Code: Subarray sum = k | Theory: Time complexity of prefix sum

PySpark: Transformations ‚Üí Code: Word count | Theory: Lazy evaluation


Oct 22 (Wed)

DSA: Sliding Window (fixed) ‚Üí Code: Max sum subarray k | Theory: Use case of sliding window

PySpark: Actions ‚Üí Code: Count distinct | Theory: Transformation vs Action


Oct 23 (Thu)

DSA: Sliding Window (variable) ‚Üí Code: Longest substring w/o repeat | Theory: Role of HashMap

PySpark: Joins ‚Üí Code: Inner join DFs | Theory: Broadcast vs shuffle join


Oct 24 (Fri)

DSA: Two pointers ‚Üí Code: 2-sum sorted | Theory: Two-pointer use

PySpark: Aggregations ‚Üí Code: GroupBy sum, avg | Theory: groupBy vs reduceByKey


Oct 27 (Mon)

DSA: Binary Search basics ‚Üí Code: Search rotated array | Theory: Complexity

PySpark: Window functions ‚Üí Code: Rank by salary | Theory: PartitionBy


Oct 28 (Tue)

DSA: Binary Search on Answer ‚Üí Code: Min capacity to ship | Theory: Monotonic function search

PySpark: UDF ‚Üí Code: Clean string with UDF | Theory: UDF disadvantages


Oct 29 (Wed)

DSA: Sorting ‚Üí Code: Quicksort | Theory: MergeSort vs QuickSort

PySpark: Caching ‚Üí Code: Cache DF | Theory: Cache vs Persist


Oct 30 (Thu)

DSA: Hashing basics ‚Üí Code: First non-repeating char | Theory: HashMap vs HashSet

PySpark: Partitioning ‚Üí Code: Repartition DF | Theory: Repartition vs Coalesce


Oct 31 (Fri)

DSA: Hashing apps ‚Üí Code: Subarray XOR = k | Theory: Hash collisions

PySpark: Broadcast ‚Üí Code: Broadcast join | Theory: Benefits of broadcast var


Nov 3 (Mon)

DSA: Stacks basics ‚Üí Code: Valid parentheses | Theory: Stack applications

PySpark: File formats ‚Üí Code: Read Parquet | Theory: Parquet vs CSV


Nov 4 (Tue)

DSA: Queue basics ‚Üí Code: Implement queue with stack | Theory: Queue uses

PySpark: Checkpointing ‚Üí Code: Add checkpoint | Theory: Checkpoint vs cache


Nov 5 (Wed)

DSA: Monotonic stack ‚Üí Code: Next greater element | Theory: Why monotonic stack?

PySpark: Accumulators ‚Üí Code: Count errors | Theory: When to use accumulator


Nov 6 (Thu)

DSA: Linked list basics ‚Üí Code: Reverse LL | Theory: Singly vs doubly LL

PySpark: Cluster manager ‚Üí Code: Run on local vs yarn | Theory: Spark on YARN vs Standalone


Nov 7 (Fri)

DSA: Linked list apps ‚Üí Code: Detect cycle | Theory: Floyd‚Äôs algorithm

PySpark: Data skew ‚Üí Code: Salting example | Theory: What is data skew?


Nov 10 (Mon)

DSA: Recursion basics ‚Üí Code: Factorial | Theory: Stack frame

PySpark: Catalyst optimizer ‚Üí Code: Explain plan | Theory: Role of optimizer


Nov 11 (Tue)

DSA: Recursion apps ‚Üí Code: Generate subsets | Theory: Recursion vs iteration

PySpark: Tungsten engine ‚Üí Code: Simple DF ops | Theory: Tungsten advantages


Nov 12 (Wed)

DSA: Backtracking ‚Üí Code: N-Queens | Theory: Backtracking vs brute force

PySpark: Partition tuning ‚Üí Code: Repartition before join | Theory: Shuffle partitions


Nov 13 (Thu)

DSA: Greedy basics ‚Üí Code: Activity selection | Theory: When greedy works?

PySpark: Joins perf ‚Üí Code: Broadcast join | Theory: Skew join handling


Nov 14 (Fri)

DSA: Greedy apps ‚Üí Code: Min coins change | Theory: Greedy vs DP

PySpark: Serialization ‚Üí Code: Kryo serializer | Theory: Why serialization matters?


Nov 17 (Mon)

DSA: DP basics ‚Üí Code: Fibonacci DP | Theory: Memoization vs tabulation

PySpark: Cluster tuning ‚Üí Code: Executor config | Theory: Driver vs Executor


Nov 18 (Tue)

DSA: DP arrays ‚Üí Code: Max subarray sum | Theory: Kadane‚Äôs algorithm

PySpark: Shuffle ‚Üí Code: Wide vs narrow trans | Theory: Shuffle cost


Nov 19 (Wed)

DSA: DP grid ‚Üí Code: Min path sum | Theory: DP states explanation

PySpark: AQE ‚Üí Code: Enable AQE | Theory: AQE benefits


Nov 20 (Thu)

DSA: DP subsequence ‚Üí Code: LCS | Theory: Applications of LCS

PySpark: Joins AQE ‚Üí Code: Skew join fix | Theory: AQE join strategies


Nov 21 (Fri)

DSA: DP knapsack ‚Üí Code: 0/1 Knapsack | Theory: Top-down vs bottom-up

PySpark: Partition strategy ‚Üí Code: Hash vs range partition | Theory: Pros/cons


Nov 24 (Mon)

DSA: Trees basics ‚Üí Code: Inorder traversal | Theory: BST vs Binary Tree

PySpark: Serialization deep ‚Üí Code: Kryo example | Theory: Serialization overhead


Nov 25 (Tue)

DSA: Trees DFS ‚Üí Code: Max depth | Theory: Preorder vs Postorder

PySpark: Resource tuning ‚Üí Code: Spark conf example | Theory: GC in Spark


Nov 26 (Wed)

DSA: Trees BFS ‚Üí Code: Level order traversal | Theory: BFS vs DFS usage

PySpark: Spill ‚Üí Code: Sort merge join spill | Theory: Spill to disk


Nov 27 (Thu)

DSA: Binary Tree paths ‚Üí Code: Root to leaf sum | Theory: Recursion in trees

PySpark: Checkpointing apps ‚Üí Code: Streaming checkpoint | Theory: Use cases


Nov 28 (Fri)

DSA: BST basics ‚Üí Code: Search BST | Theory: Why BST?

PySpark: Skew tuning ‚Üí Code: Salting keys | Theory: Handling skew keys


Dec 1 (Mon)

DSA: BST ops ‚Üí Code: Insert in BST | Theory: Balance in BST

PySpark: Catalyst plans ‚Üí Code: df.explain | Theory: Physical vs logical plan


Dec 2 (Tue)

DSA: Heaps basics ‚Üí Code: Heapify | Theory: Heap vs PriorityQueue

PySpark: Memory tuning ‚Üí Code: Spark conf memory | Theory: Spill prevention


Dec 3 (Wed)

DSA: Heap apps ‚Üí Code: Kth largest element | Theory: Heap use cases

PySpark: Broadcast tuning ‚Üí Code: Cache + broadcast | Theory: Perf benefits


Dec 4 (Thu)

DSA: Graph basics ‚Üí Code: BFS graph | Theory: Adj matrix vs list

PySpark: AQE partitions ‚Üí Code: Coalesce partitions | Theory: AQE coalescing


Dec 5 (Fri)

DSA: Graph DFS ‚Üí Code: Connected components | Theory: Recursion stack depth

PySpark: Shuffle deep ‚Üí Code: Map vs reduce side join | Theory: Shuffle mechanics


Dec 8 (Mon)

DSA: Graph shortest path ‚Üí Code: Dijkstra | Theory: Greedy in graphs

PySpark: Tungsten deep ‚Üí Code: Encoders | Theory: Tungsten execution


Dec 9 (Tue)

DSA: Graph MST ‚Üí Code: Kruskal | Theory: Union-Find DS

PySpark: CBO ‚Üí Code: Spark SQL with stats | Theory: Cost-based optimizer


Dec 10 (Wed)

DSA: Graph cycle ‚Üí Code: Detect cycle | Theory: Directed vs undirected cycles

PySpark: Spark SQL ‚Üí Code: Register temp table | Theory: SQL vs DF perf


Dec 11 (Thu)

DSA: Graph topological sort ‚Üí Code: Kahn‚Äôs algo | Theory: DAG in graphs

PySpark: Catalyst rule ‚Üí Code: Explain join reordering | Theory: Catalyst benefits


Dec 12 (Fri)

DSA: Graph advanced ‚Üí Code: Bellman-Ford | Theory: Neg cycle detection

PySpark: Wrap-up ‚Üí Code: Word count DF | Theory: Spark internals overview



---

üîπ Phase 3: Dec 15 ‚Äì Jan 23 (DW + Azure)

Dec 15 (Mon)

DW: Basics of OLTP vs OLAP ‚Üí Code: Star schema SQL query | Theory: OLAP vs OLTP difference

Azure: Storage intro ‚Üí Code: Upload file to Blob | Theory: Blob vs Data Lake


Dec 16 (Tue)

DW: Star vs Snowflake ‚Üí Code: Write fact-dim join | Theory: Which schema is better?

Azure: ADLS Gen2 ‚Üí Code: Mount storage in Spark | Theory: ADLS benefits


Dec 17 (Wed)

DW: Fact tables ‚Üí Code: Aggregate fact data | Theory: Fact table types

Azure: Azure SQL DB ‚Üí Code: Connect via Python | Theory: PaaS vs IaaS
[26/08, 9:25 am] anji‚ù§: Phase 3: Azure Data Engineering (Dec 18 ‚Äì Feb 27)


---

Week 13 (Dec 18 ‚Äì Dec 19)

(Short week since we start on Thursday)

Dec 18 (Thu)

Topic: Intro to Azure Data Services

Theory: Overview of Azure SQL DB, Synapse, Data Lake, Data Factory

Hands-on: Create free Azure account & explore portal


Dec 19 (Fri)

Topic: Azure Storage Accounts

Theory: Types (Blob, ADLS Gen2, Queue, Table)

Hands-on: Create a Blob container, upload/download files using Azure Portal & Python SDK



---

Week 14 (Dec 22 ‚Äì Dec 26)

Dec 22 (Mon)

Topic: Azure Data Lake Storage Gen2

Theory: Hierarchical namespace, access control (RBAC, ACL)

Hands-on: Mount ADLS in Databricks


Dec 23 (Tue)

Topic: Azure Blob Storage

Theory: Hot vs Cool vs Archive tiers

Hands-on: Lifecycle management policy


Dec 24 (Wed)

Topic: Azure Files & Queues

Theory: Use cases of File shares & Queues

Hands-on: Create queue and push messages


Dec 25 (Thu) üéÑ Holiday

Dec 26 (Fri)

Topic: Azure Data Factory (ADF) Basics

Theory: Pipelines, Linked Services, Datasets

Hands-on: Create pipeline to copy CSV ‚Üí Blob



---

Week 15 (Dec 29 ‚Äì Jan 2)

Dec 29 (Mon)

Topic: ADF Copy Activity

Theory: Integration Runtime, Data movement

Hands-on: Copy data Blob ‚Üí SQL DB


Dec 30 (Tue)

Topic: ADF Data Flows

Theory: Mapping & Wrangling data flows

Hands-on: Transform JSON ‚Üí Parquet


Dec 31 (Wed)

Topic: ADF Triggers & Monitoring

Theory: Schedule, Event, Tumbling Window triggers

Hands-on: Trigger pipeline every 1 hr


Jan 1 (Thu) üéâ Holiday

Jan 2 (Fri)

Topic: ADF Parameters & Variables

Theory: Dynamic content, pipeline reusability

Hands-on: Parametrize source/destination paths



---

Week 16 (Jan 5 ‚Äì Jan 9)

Jan 5 (Mon)

Topic: Azure Synapse Analytics ‚Äì Intro

Theory: Dedicated SQL Pool vs Serverless SQL Pool

Hands-on: Create Synapse workspace


Jan 6 (Tue)

Topic: Synapse Serverless Queries

Theory: Query Parquet/CSV files directly from Data Lake

Hands-on: Run OPENROWSET queries


Jan 7 (Wed)

Topic: Dedicated SQL Pools

Theory: Distribution methods (Round Robin, Hash, Replicated)

Hands-on: Create fact & dimension tables


Jan 8 (Thu)

Topic: Synapse Pipelines vs ADF

Theory: Similarities & differences

Hands-on: Build Synapse pipeline for ETL


Jan 9 (Fri)

Topic: Synapse Security

Theory: Row-level security, column-level security

Hands-on: Implement RLS



---

Week 17 (Jan 12 ‚Äì Jan 16)

Jan 12 (Mon)

Topic: Azure Databricks Intro

Theory: Apache Spark, Workspace setup

Hands-on: Create Databricks cluster


Jan 13 (Tue)

Topic: Databricks Notebooks

Theory: PySpark basics (DataFrame, RDD)

Hands-on: Read CSV & run transformations


Jan 14 (Wed)

Topic: Databricks & ADLS

Theory: Mounting ADLS, service principals

Hands-on: Mount ADLS to Databricks


Jan 15 (Thu)

Topic: Databricks Delta Lake

Theory: ACID transactions, Time travel

Hands-on: Create Delta table & update data


Jan 16 (Fri)

Topic: Databricks Optimizations

Theory: Caching, Partitioning, Z-Ordering

Hands-on: Optimize query performance



---

Week 18 (Jan 19 ‚Äì Jan 23)

Jan 19 (Mon)

Topic: Azure Event Hub

Theory: Event streaming basics

Hands-on: Send events from producer


Jan 20 (Tue)

Topic: Azure Stream Analytics

Theory: Real-time queries on streams

Hands-on: Write query to aggregate events in real-time


Jan 21 (Wed)

Topic: Databricks Structured Streaming

Theory: Spark streaming concepts

Hands-on: Stream data from Event Hub ‚Üí Databricks


Jan 22 (Thu)

Topic: Azure Data Lake + Streaming

Theory: Landing zones (raw, curated, trusted)

Hands-on: Store real-time data into ADLS


Jan 23 (Fri)

Topic: Kafka vs Event Hub

Theory: Differences & integration

Hands-on: Compare throughput test



---

Week 19 (Jan 26 ‚Äì Jan 30)

Jan 26 (Mon) üáÆüá≥ Holiday (Republic Day)

Jan 27 (Tue)

Topic: Azure Functions (Serverless)

Theory: Event-driven compute

Hands-on: Function to process Blob trigger


Jan 28 (Wed)

Topic: Logic Apps

Theory: Low-code workflows

Hands-on: Logic App to send email on Blob upload


Jan 29 (Thu)

Topic: Azure Key Vault

Theory: Secrets, Keys, Certificates

Hands-on: Store SQL password, access in ADF


Jan 30 (Fri)

Topic: Monitoring & Logging

Theory: Azure Monitor, Log Analytics, Alerts

Hands-on: Enable diagnostic logs for Data Factory



---

Week 20 (Feb 2 ‚Äì Feb 6)

Feb 2 (Mon)

Topic: Azure DevOps Basics

Theory: Repos, Pipelines, Boards

Hands-on: Create repo for SQL scripts


Feb 3 (Tue)

Topic: CI/CD for Data Factory

Theory: ARM templates, Git integration

Hands-on: Deploy ADF pipeline via DevOps


Feb 4 (Wed)

Topic: CI/CD for Synapse

Theory: Deployment pipelines

Hands-on: Publish Synapse artifacts via DevOps


Feb 5 (Thu)

Topic: Databricks CI/CD

Theory: Notebooks versioning & deployment

Hands-on: Use DevOps pipeline for Databricks


Feb 6 (Fri)

Topic: Infra as Code (IaC)

Theory: Bicep, Terraform

Hands-on: Deploy Storage + ADF using Bicep



---

Week 21 (Feb 9 ‚Äì Feb 13)

Feb 9 (Mon)

Topic: Azure Data Security

Theory: RBAC, Private Endpoints, Managed Identities

Hands-on: Restrict access via private endpoint


Feb 10 (Tue)

Topic: Encryption in Azure

Theory: SSE, CSE, TDE

Hands-on: Enable TDE for SQL DB


Feb 11 (Wed)

Topic: Networking in Azure

Theory: VNet, Subnets, Service Endpoints

Hands-on: Secure Synapse with VNet


Feb 12 (Thu)

Topic: Cost Management

Theory: Azure Pricing, Budgets

Hands-on: Set budget alerts


Feb 13 (Fri)

Topic: Governance

Theory: Policies, Blueprints

Hands-on: Apply policy to restrict VM size



---

Week 22 (Feb 16 ‚Äì Feb 20)

Feb 16 (Mon)

Topic: Data Modeling in Azure

Theory: Dimensional modeling (facts & dimensions)

Hands-on: Build star schema in Synapse


Feb 17 (Tue)

Topic: Slowly Changing Dimensions in Azure

Theory: Type 1, 2, 3 in Synapse/ADF

Hands-on: Implement SCD Type 2 in ADF


Feb 18 (Wed)

Topic: Performance Tuning in Azure SQL

Theory: Indexing, statistics

Hands-on: Query optimization demo


Feb 19 (Thu)

Topic: Synapse Best Practices

Theory: Partitioning, Materialized Views

Hands-on: Partition large fact table


Feb 20 (Fri)

Topic: Data Lake Best Practices

Theory: Naming conventions, folder structure

Hands-on: Design folder structure for Data Lake



---

Week 23 (Feb 23 ‚Äì Feb 27)

Feb 23 (Mon)

Topic: Power BI with Azure

Theory: DirectQuery vs Import from Synapse

Hands-on: Connect Power BI to Synapse


Feb 24 (Tue)

Topic: Power BI with Databricks

Theory: Lakehouse integration

Hands-on: Connect Power BI to Delta Lake


Feb 25 (Wed)

Topic: End-to-End Project Discussion

Theory: Batch + Streaming + Reporting

Hands-on: Design project architecture


Feb 26 (Thu)

Topic: End-to-End Project Implementation (Part 1)

Hands-on: Ingest data ‚Üí Transform ‚Üí Store in Synapse


Feb 27 (Fri)

Topic: End-to-End Project Implementation (Part 2)
